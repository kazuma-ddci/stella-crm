"use server";

import { revalidatePath } from "next/cache";
import { Prisma } from "@prisma/client";
import { prisma } from "@/lib/prisma";
import { generateProposalNumber } from "@/lib/proposals/generate-number";
import {
  calculateSimulation,
  type ProposalContent,
  type SimulationInput,
  type SlideVersion,
} from "@/lib/proposals/simulation";
import {
  toggleSlidePermission,
  exportSlideToPdf,
  renameSlideFile,
  getSlideFileName,
} from "@/lib/proposals/slide-generator";
import fs from "fs/promises";
import path from "path";

// 提案書データの型定義
export type ProposalData = {
  title: string;
  filePath?: string | null;
  fileName?: string | null;
  externalUrl?: string | null;
  externalService?: string | null;
  status: string;
  sentAt?: string | null;
  assignedTo?: string | null;
  note?: string | null;
};

// 提案書一覧取得
export async function getProposals(stpCompanyId: number) {
  const allProposals = await prisma.stpProposal.findMany({
    where: { stpCompanyId, deletedAt: null },
    orderBy: { createdAt: "desc" },
  });

  // エディタ用ソース提案書（proposalContent有り + sourceProposalId無し）
  const editorProposals = allProposals.filter(
    (p) => p.proposalContent !== null && p.sourceProposalId === null,
  );

  // 通常の提案書（確定済み + 手動追加）
  const proposals = allProposals.filter(
    (p) => !(p.proposalContent !== null && p.sourceProposalId === null),
  );

  // エディタ提案書ごとのunlockedバージョンをマップ化
  const editorUnlockedMap = new Map<number, number[]>();
  for (const ep of editorProposals) {
    const content = ep.proposalContent as unknown as ProposalContent | null;
    const unlockedVersions = (content?.slides || [])
      .filter((s) => s.editUnlockedAt && !s.deletedAt)
      .map((s) => s.version);
    editorUnlockedMap.set(ep.id, unlockedVersions);
  }

  const mapProposal = (p: typeof allProposals[number]) => {
    // sourceProposalIdがある場合、対応するソース提案書のunlockedVersionsを確認
    let hasUnlockedSlides = false;
    if (p.sourceProposalId && p.slideVersion) {
      const unlockedVersions = editorUnlockedMap.get(p.sourceProposalId);
      if (unlockedVersions?.includes(p.slideVersion)) {
        hasUnlockedSlides = true;
      }
    }

    return {
      id: p.id,
      stpCompanyId: p.stpCompanyId,
      submissionId: p.submissionId,
      title: p.title,
      proposalNumber: p.proposalNumber,
      filePath: p.filePath,
      fileName: p.fileName,
      externalUrl: p.externalUrl,
      externalService: p.externalService,
      status: p.status,
      sentAt: p.sentAt?.toISOString().split("T")[0] || null,
      assignedTo: p.assignedTo,
      note: p.note,
      isAutoGenerated: p.isAutoGenerated,
      hasProposalContent: p.proposalContent !== null,
      sourceProposalId: p.sourceProposalId,
      slideVersion: p.slideVersion,
      hasUnlockedSlides,
      createdAt: p.createdAt.toISOString(),
      updatedAt: p.updatedAt.toISOString(),
    };
  };

  return {
    proposals: proposals.map(mapProposal),
    editorProposals: editorProposals.map((p) => ({
      id: p.id,
      title: p.title,
      proposalNumber: p.proposalNumber,
      createdAt: p.createdAt.toISOString(),
      unlockedSlideVersions: editorUnlockedMap.get(p.id) || [],
    })),
  };
}

// 提案書追加
export async function addProposal(
  stpCompanyId: number,
  data: ProposalData
): Promise<{ success: boolean; error?: string }> {
  try {
    const proposalNumber = await generateProposalNumber();

    await prisma.stpProposal.create({
      data: {
        stpCompanyId,
        title: data.title,
        proposalNumber,
        filePath: data.filePath || null,
        fileName: data.fileName || null,
        externalUrl: data.externalUrl || null,
        externalService: data.externalService || null,
        status: data.status,
        sentAt: data.sentAt ? new Date(data.sentAt) : null,
        assignedTo: data.assignedTo || null,
        note: data.note || null,
        isAutoGenerated: false,
      },
    });

    revalidatePath("/stp/companies");
    return { success: true };
  } catch (error) {
    console.error("提案書追加エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

// 提案書更新
export async function updateProposal(
  id: number,
  data: ProposalData
): Promise<{ success: boolean; error?: string }> {
  try {
    await prisma.stpProposal.update({
      where: { id },
      data: {
        title: data.title,
        filePath: data.filePath || null,
        fileName: data.fileName || null,
        externalUrl: data.externalUrl || null,
        externalService: data.externalService || null,
        status: data.status,
        sentAt: data.sentAt ? new Date(data.sentAt) : null,
        assignedTo: data.assignedTo || null,
        note: data.note || null,
      },
    });

    revalidatePath("/stp/companies");
    return { success: true };
  } catch (error) {
    console.error("提案書更新エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

// 提案書削除
export async function deleteProposal(id: number): Promise<{ success: boolean; error?: string }> {
  try {
    await prisma.stpProposal.delete({
      where: { id },
    });

    revalidatePath("/stp/companies");
    return { success: true };
  } catch (error) {
    console.error("提案書削除エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

// 提案書をproposalContent込みで取得
export async function getProposalWithContent(id: number) {
  const proposal = await prisma.stpProposal.findUnique({
    where: { id },
    include: {
      submission: true,
      confirmedVersions: {
        select: { id: true, slideVersion: true, status: true },
      },
    },
  });

  if (!proposal) return null;

  return {
    id: proposal.id,
    stpCompanyId: proposal.stpCompanyId,
    submissionId: proposal.submissionId,
    title: proposal.title,
    proposalNumber: proposal.proposalNumber,
    filePath: proposal.filePath,
    fileName: proposal.fileName,
    externalUrl: proposal.externalUrl,
    externalService: proposal.externalService,
    status: proposal.status,
    isAutoGenerated: proposal.isAutoGenerated,
    note: proposal.note,
    sourceProposalId: proposal.sourceProposalId,
    slideVersion: proposal.slideVersion,
    proposalContent: proposal.proposalContent as unknown as ProposalContent | null,
    createdAt: proposal.createdAt.toISOString(),
    updatedAt: proposal.updatedAt.toISOString(),
    submission: proposal.submission ? {
      companyName: proposal.submission.companyName,
      contactName: proposal.submission.contactName,
    } : null,
    confirmedVersions: proposal.confirmedVersions,
  };
}

// proposalContent を更新
export async function updateProposalContent(
  id: number,
  content: ProposalContent,
): Promise<{ success: boolean; error?: string }> {
  try {
    await prisma.stpProposal.update({
      where: { id },
      data: {
        proposalContent: JSON.parse(JSON.stringify(content)) as Prisma.InputJsonValue,
      },
    });

    revalidatePath("/stp/proposals");
    return { success: true };
  } catch (error) {
    console.error("提案書コンテンツ更新エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

// 入力値から再計算して保存
export async function regenerateProposal(
  id: number,
  input: SimulationInput,
): Promise<{ success: boolean; content?: ProposalContent; error?: string }> {
  try {
    const existing = await prisma.stpProposal.findUnique({ where: { id } });
    const existingContent = existing?.proposalContent as unknown as ProposalContent | null;

    const result = calculateSimulation(input);
    const content: ProposalContent = {
      input,
      originalInput: existingContent?.originalInput,
      result,
      generatedAt: new Date().toISOString(),
      version: 1,
      slides: existingContent?.slides,
    };

    await prisma.stpProposal.update({
      where: { id },
      data: {
        proposalContent: JSON.parse(JSON.stringify(content)) as Prisma.InputJsonValue,
      },
    });

    revalidatePath("/stp/proposals");
    return { success: true, content };
  } catch (error) {
    console.error("提案書再生成エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

/**
 * バージョンを確定して提案書管理に登録
 * - PDFを生成・保存
 * - スライド権限を閲覧専用に変更
 * - 提案書管理エントリを作成
 */
export async function confirmProposal(
  editorProposalId: number,
  version: number,
): Promise<{ success: boolean; confirmedProposalId?: number; error?: string }> {
  try {
    const proposal = await prisma.stpProposal.findUnique({
      where: { id: editorProposalId },
    });
    if (!proposal) return { success: false, error: "提案書が見つかりません" };

    const content = proposal.proposalContent as unknown as ProposalContent | null;
    if (!content?.slides) return { success: false, error: "スライドが生成されていません" };

    const slide = content.slides.find((s) => s.version === version && !s.deletedAt);
    if (!slide) return { success: false, error: `ver.${version}が見つかりません` };

    if (slide.confirmedProposalId) {
      return { success: false, error: "このバージョンは既に確定済みです。上書きを使用してください" };
    }

    // 1. PDFを生成・保存
    const pdfBuffer = await exportSlideToPdf(slide.slideFileId);
    const now = new Date();
    const yearMonth = `${now.getFullYear()}/${String(now.getMonth() + 1).padStart(2, "0")}`;
    const uploadDir = path.join(process.cwd(), "public/uploads/proposals", yearMonth);
    await fs.mkdir(uploadDir, { recursive: true });

    const pdfFileName = `proposal-${editorProposalId}-v${version}-${Date.now()}.pdf`;
    const filePath = path.join(uploadDir, pdfFileName);
    const publicPath = `/uploads/proposals/${yearMonth}/${pdfFileName}`;
    await fs.writeFile(filePath, pdfBuffer);

    // 2. スライド権限を閲覧専用に
    await toggleSlidePermission(slide.slideFileId, "reader");

    // 3. 提案書管理エントリを作成
    const proposalNumber = await generateProposalNumber();
    const companyName = content.input.companyName || "提案書";

    const confirmed = await prisma.stpProposal.create({
      data: {
        stpCompanyId: proposal.stpCompanyId,
        submissionId: proposal.submissionId,
        title: `${companyName} 様向け提案書 ver.${version}`,
        proposalNumber,
        filePath: publicPath,
        fileName: `${companyName}_提案書_v${version}.pdf`,
        status: "completed",
        isAutoGenerated: true,
        sourceProposalId: editorProposalId,
        slideVersion: version,
        note: `リード回答提案書 ver.${version} から確定`,
      },
    });

    // 4. proposalContentのslides[]にconfirmedProposalIdを記録
    const updatedSlides = content.slides.map((s) =>
      s.version === version ? { ...s, confirmedProposalId: confirmed.id } : s,
    );
    const updatedContent: ProposalContent = { ...content, slides: updatedSlides };

    await prisma.stpProposal.update({
      where: { id: editorProposalId },
      data: {
        proposalContent: JSON.parse(JSON.stringify(updatedContent)) as Prisma.InputJsonValue,
      },
    });

    revalidatePath("/stp/companies");
    revalidatePath("/stp/proposals");
    return { success: true, confirmedProposalId: confirmed.id };
  } catch (error) {
    console.error("提案書確定エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

/**
 * 確定済みバージョンを上書き
 * - PDFを再生成
 * - 提案書管理エントリを更新
 * - スライド権限を閲覧専用に戻す
 */
export async function overwriteProposal(
  editorProposalId: number,
  version: number,
): Promise<{ success: boolean; error?: string }> {
  try {
    const proposal = await prisma.stpProposal.findUnique({
      where: { id: editorProposalId },
    });
    if (!proposal) return { success: false, error: "提案書が見つかりません" };

    const content = proposal.proposalContent as unknown as ProposalContent | null;
    if (!content?.slides) return { success: false, error: "スライドが生成されていません" };

    const slide = content.slides.find((s) => s.version === version && !s.deletedAt);
    if (!slide) return { success: false, error: `ver.${version}が見つかりません` };

    if (!slide.confirmedProposalId) {
      return { success: false, error: "このバージョンは未確定です。確定を使用してください" };
    }

    // 1. PDFを再生成
    const pdfBuffer = await exportSlideToPdf(slide.slideFileId);
    const now = new Date();
    const yearMonth = `${now.getFullYear()}/${String(now.getMonth() + 1).padStart(2, "0")}`;
    const uploadDir = path.join(process.cwd(), "public/uploads/proposals", yearMonth);
    await fs.mkdir(uploadDir, { recursive: true });

    const pdfFileName = `proposal-${editorProposalId}-v${version}-${Date.now()}.pdf`;
    const filePath = path.join(uploadDir, pdfFileName);
    const publicPath = `/uploads/proposals/${yearMonth}/${pdfFileName}`;
    await fs.writeFile(filePath, pdfBuffer);

    // 2. スライド権限を閲覧専用に戻す
    await toggleSlidePermission(slide.slideFileId, "reader");

    // 3. 提案書管理エントリを更新
    const companyName = content.input.companyName || "提案書";
    await prisma.stpProposal.update({
      where: { id: slide.confirmedProposalId },
      data: {
        filePath: publicPath,
        fileName: `${companyName}_提案書_v${version}.pdf`,
        updatedAt: new Date(),
      },
    });

    // 4. editUnlockedAt をクリア
    const updatedSlides = content.slides.map((s) =>
      s.version === version ? { ...s, editUnlockedAt: null } : s,
    );
    const updatedContent: ProposalContent = { ...content, slides: updatedSlides };
    await prisma.stpProposal.update({
      where: { id: editorProposalId },
      data: {
        proposalContent: JSON.parse(JSON.stringify(updatedContent)) as Prisma.InputJsonValue,
      },
    });

    revalidatePath("/stp/companies");
    revalidatePath("/stp/proposals");
    return { success: true };
  } catch (error) {
    console.error("提案書上書きエラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

/**
 * スライドバージョンを論理削除
 * - 確定済みの場合は提案書管理エントリも論理削除
 * - Drive上のファイル名に「_削除済み」を追加
 */
export async function deleteSlideVersion(
  editorProposalId: number,
  version: number,
): Promise<{ success: boolean; error?: string }> {
  try {
    const proposal = await prisma.stpProposal.findUnique({
      where: { id: editorProposalId },
    });
    if (!proposal) return { success: false, error: "提案書が見つかりません" };

    const content = proposal.proposalContent as unknown as ProposalContent | null;
    if (!content?.slides) return { success: false, error: "スライドが生成されていません" };

    const slide = content.slides.find((s) => s.version === version && !s.deletedAt);
    if (!slide) return { success: false, error: `ver.${version}が見つかりません` };

    // 確定済みの場合は提案書管理エントリも削除
    if (slide.confirmedProposalId) {
      await prisma.stpProposal.update({
        where: { id: slide.confirmedProposalId },
        data: { deletedAt: new Date() },
      });
    }

    // 編集中（writer権限）の場合は閲覧専用に戻す
    if (slide.editUnlockedAt) {
      try {
        await toggleSlidePermission(slide.slideFileId, "reader");
      } catch (e) {
        console.error("削除時の権限リバートエラー（無視）:", e);
      }
    }

    // Drive上のファイル名に「_削除済み」を追加
    try {
      const currentName = await getSlideFileName(slide.slideFileId);
      if (currentName && !currentName.includes("_削除済み")) {
        await renameSlideFile(slide.slideFileId, `${currentName}_削除済み`);
      }
    } catch (e) {
      console.error("Drive名変更エラー（無視）:", e);
    }

    // proposalContentのslides[]に論理削除マーク
    const updatedSlides = content.slides.map((s) =>
      s.version === version
        ? { ...s, deletedAt: new Date().toISOString(), confirmedProposalId: null }
        : s,
    );
    const updatedContent: ProposalContent = { ...content, slides: updatedSlides };

    await prisma.stpProposal.update({
      where: { id: editorProposalId },
      data: {
        proposalContent: JSON.parse(JSON.stringify(updatedContent)) as Prisma.InputJsonValue,
      },
    });

    revalidatePath("/stp/companies");
    revalidatePath("/stp/proposals");
    return { success: true };
  } catch (error) {
    console.error("バージョン削除エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

/**
 * 確定済みスライドの編集を解除（権限を編集可能に戻す）
 */
export async function unlockSlideForEdit(
  editorProposalId: number,
  version: number,
): Promise<{ success: boolean; error?: string }> {
  try {
    const proposal = await prisma.stpProposal.findUnique({
      where: { id: editorProposalId },
    });
    if (!proposal) return { success: false, error: "提案書が見つかりません" };

    const content = proposal.proposalContent as unknown as ProposalContent | null;
    if (!content?.slides) return { success: false, error: "スライドが生成されていません" };

    const slide = content.slides.find((s) => s.version === version && !s.deletedAt);
    if (!slide) return { success: false, error: `ver.${version}が見つかりません` };

    // 権限を編集可能に変更
    await toggleSlidePermission(slide.slideFileId, "writer");

    // editUnlockedAt を記録
    const updatedSlides = content.slides.map((s) =>
      s.version === version ? { ...s, editUnlockedAt: new Date().toISOString() } : s,
    );
    const updatedContent: ProposalContent = { ...content, slides: updatedSlides };
    await prisma.stpProposal.update({
      where: { id: editorProposalId },
      data: {
        proposalContent: JSON.parse(JSON.stringify(updatedContent)) as Prisma.InputJsonValue,
      },
    });

    return { success: true };
  } catch (error) {
    console.error("スライド編集解除エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

/**
 * スライド編集後に権限を閲覧専用に戻す
 */
export async function lockSlideAfterEdit(
  editorProposalId: number,
  version: number,
): Promise<{ success: boolean; error?: string }> {
  try {
    const proposal = await prisma.stpProposal.findUnique({
      where: { id: editorProposalId },
    });
    if (!proposal) return { success: false, error: "提案書が見つかりません" };

    const content = proposal.proposalContent as unknown as ProposalContent | null;
    if (!content?.slides) return { success: false, error: "スライドが生成されていません" };

    const slide = content.slides.find((s) => s.version === version && !s.deletedAt);
    if (!slide) return { success: false, error: `ver.${version}が見つかりません` };

    // 権限を閲覧専用に戻す
    await toggleSlidePermission(slide.slideFileId, "reader");

    // editUnlockedAt をクリア
    const updatedSlides = content.slides.map((s) =>
      s.version === version ? { ...s, editUnlockedAt: null } : s,
    );
    const updatedContent: ProposalContent = { ...content, slides: updatedSlides };
    await prisma.stpProposal.update({
      where: { id: editorProposalId },
      data: {
        proposalContent: JSON.parse(JSON.stringify(updatedContent)) as Prisma.InputJsonValue,
      },
    });

    revalidatePath("/stp/proposals");
    return { success: true };
  } catch (error) {
    console.error("スライド権限戻しエラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

/**
 * エディタ提案書の未戻し全スライド権限を一括で閲覧専用に戻す
 */
export async function lockAllUnlockedSlides(
  editorProposalId: number,
): Promise<{ success: boolean; error?: string }> {
  try {
    const proposal = await prisma.stpProposal.findUnique({
      where: { id: editorProposalId },
    });
    if (!proposal) return { success: false, error: "提案書が見つかりません" };

    const content = proposal.proposalContent as unknown as ProposalContent | null;
    if (!content?.slides) return { success: false, error: "スライドが生成されていません" };

    const unlockedSlides = content.slides.filter(
      (s) => s.editUnlockedAt && !s.deletedAt,
    );

    if (unlockedSlides.length === 0) {
      return { success: true };
    }

    // 各スライドの権限を閲覧専用に戻す
    for (const slide of unlockedSlides) {
      try {
        await toggleSlidePermission(slide.slideFileId, "reader");
      } catch (e) {
        console.error(`スライド ver.${slide.version} の権限戻しエラー:`, e);
        throw e;
      }
    }

    // 全てのeditUnlockedAtをクリア
    const updatedSlides = content.slides.map((s) =>
      s.editUnlockedAt && !s.deletedAt ? { ...s, editUnlockedAt: null } : s,
    );
    const updatedContent: ProposalContent = { ...content, slides: updatedSlides };
    await prisma.stpProposal.update({
      where: { id: editorProposalId },
      data: {
        proposalContent: JSON.parse(JSON.stringify(updatedContent)) as Prisma.InputJsonValue,
      },
    });

    revalidatePath("/stp/companies");
    revalidatePath("/stp/proposals");
    return { success: true };
  } catch (error) {
    console.error("一括権限戻しエラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

// スタッフ一覧取得（担当者の選択用）
export async function getStaffListForProposal() {
  const staffList = await prisma.masterStaff.findMany({
    where: { isActive: true, isSystemUser: false },
    orderBy: [{ displayOrder: "asc" }, { name: "asc" }],
    select: {
      id: true,
      name: true,
    },
  });

  return staffList.map((s) => ({
    value: s.name,
    label: s.name,
  }));
}
