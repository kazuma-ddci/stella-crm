"use server";

import { revalidatePath } from "next/cache";
import { Prisma } from "@prisma/client";
import { prisma } from "@/lib/prisma";
import { generateProposalNumber } from "@/lib/proposals/generate-number";
import { calculateSimulation, type ProposalContent, type SimulationInput } from "@/lib/proposals/simulation";

// 提案書データの型定義
export type ProposalData = {
  title: string;
  filePath?: string | null;
  fileName?: string | null;
  externalUrl?: string | null;
  externalService?: string | null;
  status: string;
  sentAt?: string | null;
  assignedTo?: string | null;
  note?: string | null;
};

// 提案書一覧取得
export async function getProposals(stpCompanyId: number) {
  const proposals = await prisma.stpProposal.findMany({
    where: { stpCompanyId },
    orderBy: { createdAt: "desc" },
  });

  return proposals.map((p) => ({
    id: p.id,
    stpCompanyId: p.stpCompanyId,
    submissionId: p.submissionId,
    title: p.title,
    proposalNumber: p.proposalNumber,
    filePath: p.filePath,
    fileName: p.fileName,
    externalUrl: p.externalUrl,
    externalService: p.externalService,
    status: p.status,
    sentAt: p.sentAt?.toISOString().split("T")[0] || null,
    assignedTo: p.assignedTo,
    note: p.note,
    isAutoGenerated: p.isAutoGenerated,
    hasProposalContent: p.proposalContent !== null,
    createdAt: p.createdAt.toISOString(),
    updatedAt: p.updatedAt.toISOString(),
  }));
}

// 提案書追加
export async function addProposal(
  stpCompanyId: number,
  data: ProposalData
): Promise<{ success: boolean; error?: string }> {
  try {
    const proposalNumber = await generateProposalNumber();

    await prisma.stpProposal.create({
      data: {
        stpCompanyId,
        title: data.title,
        proposalNumber,
        filePath: data.filePath || null,
        fileName: data.fileName || null,
        externalUrl: data.externalUrl || null,
        externalService: data.externalService || null,
        status: data.status,
        sentAt: data.sentAt ? new Date(data.sentAt) : null,
        assignedTo: data.assignedTo || null,
        note: data.note || null,
        isAutoGenerated: false,
      },
    });

    revalidatePath("/stp/companies");
    return { success: true };
  } catch (error) {
    console.error("提案書追加エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

// 提案書更新
export async function updateProposal(
  id: number,
  data: ProposalData
): Promise<{ success: boolean; error?: string }> {
  try {
    await prisma.stpProposal.update({
      where: { id },
      data: {
        title: data.title,
        filePath: data.filePath || null,
        fileName: data.fileName || null,
        externalUrl: data.externalUrl || null,
        externalService: data.externalService || null,
        status: data.status,
        sentAt: data.sentAt ? new Date(data.sentAt) : null,
        assignedTo: data.assignedTo || null,
        note: data.note || null,
      },
    });

    revalidatePath("/stp/companies");
    return { success: true };
  } catch (error) {
    console.error("提案書更新エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

// 提案書削除
export async function deleteProposal(id: number): Promise<{ success: boolean; error?: string }> {
  try {
    await prisma.stpProposal.delete({
      where: { id },
    });

    revalidatePath("/stp/companies");
    return { success: true };
  } catch (error) {
    console.error("提案書削除エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

// 提案書をproposalContent込みで取得
export async function getProposalWithContent(id: number) {
  const proposal = await prisma.stpProposal.findUnique({
    where: { id },
    include: {
      submission: true,
    },
  });

  if (!proposal) return null;

  return {
    id: proposal.id,
    stpCompanyId: proposal.stpCompanyId,
    submissionId: proposal.submissionId,
    title: proposal.title,
    proposalNumber: proposal.proposalNumber,
    filePath: proposal.filePath,
    fileName: proposal.fileName,
    externalUrl: proposal.externalUrl,
    externalService: proposal.externalService,
    status: proposal.status,
    isAutoGenerated: proposal.isAutoGenerated,
    note: proposal.note,
    proposalContent: proposal.proposalContent as unknown as ProposalContent | null,
    createdAt: proposal.createdAt.toISOString(),
    updatedAt: proposal.updatedAt.toISOString(),
    submission: proposal.submission ? {
      companyName: proposal.submission.companyName,
      contactName: proposal.submission.contactName,
    } : null,
  };
}

// proposalContent を更新
export async function updateProposalContent(
  id: number,
  content: ProposalContent,
): Promise<{ success: boolean; error?: string }> {
  try {
    await prisma.stpProposal.update({
      where: { id },
      data: {
        proposalContent: JSON.parse(JSON.stringify(content)) as Prisma.InputJsonValue,
      },
    });

    revalidatePath("/stp/proposals");
    return { success: true };
  } catch (error) {
    console.error("提案書コンテンツ更新エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

// 入力値から再計算して保存
export async function regenerateProposal(
  id: number,
  input: SimulationInput,
): Promise<{ success: boolean; content?: ProposalContent; error?: string }> {
  try {
    const result = calculateSimulation(input);
    const content: ProposalContent = {
      input,
      result,
      generatedAt: new Date().toISOString(),
      version: 1,
    };

    await prisma.stpProposal.update({
      where: { id },
      data: {
        proposalContent: JSON.parse(JSON.stringify(content)) as Prisma.InputJsonValue,
      },
    });

    revalidatePath("/stp/proposals");
    return { success: true, content };
  } catch (error) {
    console.error("提案書再生成エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

// スタッフ一覧取得（担当者の選択用）
export async function getStaffListForProposal() {
  const staffList = await prisma.masterStaff.findMany({
    where: { isActive: true, isSystemUser: false },
    orderBy: [{ displayOrder: "asc" }, { name: "asc" }],
    select: {
      id: true,
      name: true,
    },
  });

  return staffList.map((s) => ({
    value: s.name,
    label: s.name,
  }));
}
