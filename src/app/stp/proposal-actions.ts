"use server";

import { revalidatePath } from "next/cache";
import { prisma } from "@/lib/prisma";
import { generateProposalNumber } from "@/lib/proposals/generate-number";

// 提案書データの型定義
export type ProposalData = {
  title: string;
  filePath?: string | null;
  fileName?: string | null;
  externalUrl?: string | null;
  externalService?: string | null;
  status: string;
  sentAt?: string | null;
  assignedTo?: string | null;
  note?: string | null;
};

// 提案書一覧取得
export async function getProposals(stpCompanyId: number) {
  const proposals = await prisma.stpProposal.findMany({
    where: { stpCompanyId },
    orderBy: { createdAt: "desc" },
  });

  return proposals.map((p) => ({
    id: p.id,
    stpCompanyId: p.stpCompanyId,
    submissionId: p.submissionId,
    title: p.title,
    proposalNumber: p.proposalNumber,
    filePath: p.filePath,
    fileName: p.fileName,
    externalUrl: p.externalUrl,
    externalService: p.externalService,
    status: p.status,
    sentAt: p.sentAt?.toISOString().split("T")[0] || null,
    assignedTo: p.assignedTo,
    note: p.note,
    isAutoGenerated: p.isAutoGenerated,
    createdAt: p.createdAt.toISOString(),
    updatedAt: p.updatedAt.toISOString(),
  }));
}

// 提案書追加
export async function addProposal(
  stpCompanyId: number,
  data: ProposalData
): Promise<{ success: boolean; error?: string }> {
  try {
    const proposalNumber = await generateProposalNumber();

    await prisma.stpProposal.create({
      data: {
        stpCompanyId,
        title: data.title,
        proposalNumber,
        filePath: data.filePath || null,
        fileName: data.fileName || null,
        externalUrl: data.externalUrl || null,
        externalService: data.externalService || null,
        status: data.status,
        sentAt: data.sentAt ? new Date(data.sentAt) : null,
        assignedTo: data.assignedTo || null,
        note: data.note || null,
        isAutoGenerated: false,
      },
    });

    revalidatePath("/stp/companies");
    return { success: true };
  } catch (error) {
    console.error("提案書追加エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

// 提案書更新
export async function updateProposal(
  id: number,
  data: ProposalData
): Promise<{ success: boolean; error?: string }> {
  try {
    await prisma.stpProposal.update({
      where: { id },
      data: {
        title: data.title,
        filePath: data.filePath || null,
        fileName: data.fileName || null,
        externalUrl: data.externalUrl || null,
        externalService: data.externalService || null,
        status: data.status,
        sentAt: data.sentAt ? new Date(data.sentAt) : null,
        assignedTo: data.assignedTo || null,
        note: data.note || null,
      },
    });

    revalidatePath("/stp/companies");
    return { success: true };
  } catch (error) {
    console.error("提案書更新エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

// 提案書削除
export async function deleteProposal(id: number): Promise<{ success: boolean; error?: string }> {
  try {
    await prisma.stpProposal.delete({
      where: { id },
    });

    revalidatePath("/stp/companies");
    return { success: true };
  } catch (error) {
    console.error("提案書削除エラー:", error);
    const errorMessage = error instanceof Error ? error.message : "不明なエラーが発生しました";
    return { success: false, error: errorMessage };
  }
}

// スタッフ一覧取得（担当者の選択用）
export async function getStaffListForProposal() {
  const staffList = await prisma.masterStaff.findMany({
    where: { isActive: true, isSystemUser: false },
    orderBy: [{ displayOrder: "asc" }, { name: "asc" }],
    select: {
      id: true,
      name: true,
    },
  });

  return staffList.map((s) => ({
    value: s.name,
    label: s.name,
  }));
}
